import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx';
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { ExportOptions } from '@/types/scribe';

export class ExportService {
  static async exportToDocx(
    content: string,
    title: string,
    options: ExportOptions = { format: 'docx', includeMetadata: true, processFigures: true }
  ): Promise<Blob> {
    try {
      // Process content to handle figures and formatting
      const processedContent = this.processFigures(content, options.processFigures);
      
      // Split content into paragraphs and identify headings
      const lines = processedContent.split('\n').filter(line => line.trim());
      const docElements: any[] = [];

      // Add title
      docElements.push(
        new Paragraph({
          children: [new TextRun({ text: title, bold: true, size: 28 })],
          heading: HeadingLevel.TITLE,
          spacing: { after: 400 },
        })
      );

      // Add metadata if requested
      if (options.includeMetadata) {
        docElements.push(
          new Paragraph({
            children: [
              new TextRun({ 
                text: `Generated by ThinqScribe on ${new Date().toLocaleDateString()}`, 
                italics: true, 
                size: 20 
              })
            ],
            spacing: { after: 200 },
          })
        );
      }

      // Process content lines
      for (const line of lines) {
        if (this.isHeading(line)) {
          const level = this.getHeadingLevel(line);
          const text = this.cleanHeadingText(line);
          
          docElements.push(
            new Paragraph({
              children: [new TextRun({ text, bold: true, size: 24 - (level * 2) })],
              heading: level === 1 ? HeadingLevel.HEADING_1 : 
                      level === 2 ? HeadingLevel.HEADING_2 : 
                      HeadingLevel.HEADING_3,
              spacing: { before: 300, after: 200 },
            })
          );
        } else if (this.isFigure(line)) {
          docElements.push(
            new Paragraph({
              children: [new TextRun({ text: line, italics: true, color: '666666' })],
              spacing: { before: 200, after: 200 },
            })
          );
        } else if (line.trim()) {
          docElements.push(
            new Paragraph({
              children: [new TextRun({ text: line })],
              spacing: { after: 100 },
            })
          );
        }
      }

      const doc = new Document({
        sections: [{
          children: docElements,
        }],
      });

      return await Packer.toBlob(doc);
    } catch (error) {
      console.error('Error exporting to DOCX:', error);
      throw new Error('Failed to export document to DOCX format');
    }
  }

  static async exportToPdf(
    content: string,
    title: string,
    options: ExportOptions = { format: 'pdf', includeMetadata: true, processFigures: true }
  ): Promise<Blob> {
    try {
      const pdf = new jsPDF();
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const margin = 20;
      const maxWidth = pageWidth - (margin * 2);
      
      let yPosition = margin;

      // Add title
      pdf.setFontSize(20);
      pdf.setFont('helvetica', 'bold');
      const titleLines = pdf.splitTextToSize(title, maxWidth);
      pdf.text(titleLines, margin, yPosition);
      yPosition += titleLines.length * 10 + 10;

      // Add metadata if requested
      if (options.includeMetadata) {
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'italic');
        pdf.text(`Generated by ThinqScribe on ${new Date().toLocaleDateString()}`, margin, yPosition);
        yPosition += 15;
      }

      // Process content
      const processedContent = this.processFigures(content, options.processFigures);
      const lines = processedContent.split('\n').filter(line => line.trim());

      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(12);

      for (const line of lines) {
        // Check if we need a new page
        if (yPosition > pageHeight - margin) {
          pdf.addPage();
          yPosition = margin;
        }

        if (this.isHeading(line)) {
          const level = this.getHeadingLevel(line);
          const text = this.cleanHeadingText(line);
          
          pdf.setFont('helvetica', 'bold');
          pdf.setFontSize(16 - (level * 2));
          
          const headingLines = pdf.splitTextToSize(text, maxWidth);
          pdf.text(headingLines, margin, yPosition);
          yPosition += headingLines.length * 8 + 5;
          
          pdf.setFont('helvetica', 'normal');
          pdf.setFontSize(12);
        } else if (this.isFigure(line)) {
          pdf.setFont('helvetica', 'italic');
          pdf.setTextColor(100, 100, 100);
          
          const figureLines = pdf.splitTextToSize(line, maxWidth);
          pdf.text(figureLines, margin, yPosition);
          yPosition += figureLines.length * 6 + 5;
          
          pdf.setFont('helvetica', 'normal');
          pdf.setTextColor(0, 0, 0);
        } else if (line.trim()) {
          const textLines = pdf.splitTextToSize(line, maxWidth);
          pdf.text(textLines, margin, yPosition);
          yPosition += textLines.length * 6 + 3;
        }
      }

      return pdf.output('blob');
    } catch (error) {
      console.error('Error exporting to PDF:', error);
      throw new Error('Failed to export document to PDF format');
    }
  }

  static exportToTxt(
    content: string,
    title: string,
    options: ExportOptions = { format: 'txt', includeMetadata: true, processFigures: true }
  ): Blob {
    try {
      let textContent = title + '\n' + '='.repeat(title.length) + '\n\n';
      
      if (options.includeMetadata) {
        textContent += `Generated by ThinqScribe on ${new Date().toLocaleDateString()}\n\n`;
      }
      
      const processedContent = this.processFigures(content, options.processFigures);
      textContent += processedContent;
      
      return new Blob([textContent], { type: 'text/plain;charset=utf-8' });
    } catch (error) {
      console.error('Error exporting to TXT:', error);
      throw new Error('Failed to export document to TXT format');
    }
  }

  private static processFigures(content: string, processFigures: boolean): string {
    if (!processFigures) return content;
    
    // Replace figure placeholders with formatted figure captions
    return content.replace(/\[FIGURE (\d+): ([^\]]+)\]/g, (match, figNum, description) => {
      return `\n[Figure ${figNum}: ${description}]\n`;
    });
  }

  private static isHeading(line: string): boolean {
    return /^#{1,6}\s/.test(line) || /^[A-Z][^.!?]*$/.test(line.trim()) && line.length < 100;
  }

  private static getHeadingLevel(line: string): number {
    const hashMatch = line.match(/^#{1,6}/);
    if (hashMatch) {
      return hashMatch[0].length;
    }
    return 1; // Default to level 1 for non-markdown headings
  }

  private static cleanHeadingText(line: string): string {
    return line.replace(/^#{1,6}\s*/, '').trim();
  }

  private static isFigure(line: string): boolean {
    return /\[FIGURE \d+:/.test(line) || /\[Figure \d+:/.test(line);
  }

  static downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  static async exportContent(
    content: string,
    title: string,
    format: 'docx' | 'pdf' | 'txt',
    options?: Partial<ExportOptions>
  ): Promise<void> {
    const exportOptions: ExportOptions = {
      format,
      includeMetadata: true,
      processFigures: true,
      ...options,
    };

    try {
      let blob: Blob;
      let filename: string;

      switch (format) {
        case 'docx':
          blob = await this.exportToDocx(content, title, exportOptions);
          filename = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.docx`;
          break;
        case 'pdf':
          blob = await this.exportToPdf(content, title, exportOptions);
          filename = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf`;
          break;
        case 'txt':
          blob = this.exportToTxt(content, title, exportOptions);
          filename = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
          break;
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }

      this.downloadBlob(blob, filename);
    } catch (error) {
      console.error(`Error exporting to ${format}:`, error);
      throw error;
    }
  }
}